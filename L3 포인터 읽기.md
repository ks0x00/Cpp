# 포인터 읽기

C/C++에서 포인터의 이해는 참 어려운 과제이다. 지레 겁을 먹고 뒤로 물러나게 만든다. 그러나 익숙해지면 그리 어려운 것이 아니다.
이해할 때까지 깊이 생각하는 것이 중요하다.

포인터를 선언하는 문장을 이해하려면 읽는 것이 중요하다. 어떻게 읽는지 알아보자.

## 변수를 기준으로 읽어라
포인터는 변수를 중심으로 읽으면 편리하다. 변수부터 읽고 주변으로 한 단계씩 넓혀 나간다.

### 가장 단순한 형태

간단한 예부터 살펴보자.
```C++
int *p;
```
변수 `p`에서 가까운 것부터 읽는다. `p`에서 가장 가까운 것은 `*`이다.

- `*p`: `p`는 포인터이다.
- `int *p`: `p`는 `int`의 포인터이다

`p`는 `int` 형식 변수를 가리킨다(point). 곧 `int` 형식 변수의 주소를 값으로 가진다. ~~엄밀히 말하면 반드시 주소일 필요는 없으나 그렇게 생각하는 것이 상황을 단순하게 만든다.~~ 따라서
```C++
int x = 123;
int *p = &x;
std::cout << *p << std::endl;
```
또는
```C++
int x = 123;
int *p = &x;
std::cout << p[0] << std::endl;
```
과 같이 쓸 수 있다. `p`에는 `x`가 차지하는 공간의 첫 바이트의 주소가 저장된다.
`p[0]`은 컴파일러에 의하여 `*(p + 0)`으로 번역된다. 따라서 `p[0]`은 `*p`와 완전히 일치한다.

포인터를 선언하는 문장
```C++
int *p = &x;
```
의 `*`와 포인터를 사용하는 문장
```C++
std::cout << *p << std::endl;
```
의 `*`는 그 역할이 다르다. **다른 문자**라고 생각하는 것이 좋다. 헷갈린다면 `*p` 대신 `p[0]`를 사용하자.

### 동적 메모리 할당
동적 메모리 할당은
```C++
int *p = new int;
*p = 123;  // p[0] = 123과 완전히 일치한다
// 코드
delete p;  // 메모리 반납
```
또는
```C++
int *p = new int[3];)
for(int i = 0; i < 3; i++)
    p[i] = i;  // *(p + i) = i와 완전히 일치한다
// 코드
delete[] p;  // 메모리 반납
```
와 같은 형식으로 이루어진다. `p`에는 할당된 메모리 공간의 첫 바이트의 주소가 저장된다.

`delete`는 `new`로 할당된 메모리를 반납한다. `new int[3]`과 같이 대괄호(`[]`)를 써서 할당된 메모리는 `delete[]`와 같이 대괄호를 써서 반납한다.

#### 참고
`p + i`는 `p`에서 (`int`의 크기) * i 만큼 이동한 곳의 주소이다. `p`의 자료 형식이 `int *`이기 때문이다.

### 이중 포인터

이중 포인터는
```C++
int **P;
```
와 같은 포인터의 포인터를 말한다. 이것을 읽어 보자.

- `*p`: `p`는 포인터이다
- `**p`: `p`는 포인터의 포인터이다
- `int **p`: `p`는 `int`의 포인터의 포인터이다.

`p`가 `int`의 포인터의 포인터이므로 `p`는 `int *`의 포인터이다. 곧, `*p`에는 `int *`가 저장된다. 따라서 동적 메모리 할당은
```C++
p = new int *[3];
```
과 같은 형식으로 이루어진다. 여기서 `p[0]`, `p[1]`, `p[2]`는 `int *` 형식이다. 여기에 다시 메모리를 할당하면
```C++
p[0] = new int[2];
p[1] = new int[5];
p[2] = new int[4];
```
와 같은 형식이 된다.

정리해 보자.
```C++
int **p = new int *[3];
p[0] = new int[2]
p[1] = new int[5];
p[2] = new int[4];

p[0][1] = 55;
p[2][3] = 999;
// 코드
delete[] p[0];
delete[] p[1];
delete[] p[2];
delete[] p;
```

`new`의 개수와 `delete`의 개수는 **일치**한다. 할당한 만큼 반환한다.

### 포인터 배열
각 요소가 `int` 형식인 배열은
```C++
int arr[3];
arr[0] = 987;
arr[1] = 999;
arr[2] = 123;
```
과 같은 꼴로 선언하여 사용한다.

포인터 배열은 각 요소가 포인터인 배열을 말한다. 다음과 같이 선언한다.
```C++
int *p[3];
```
선언을 읽어보자. 변수 `p`에는 `*`와 대괄호(`[]`)가 붙어 있다. 대괄호의 우선순위가 높으므로 그것부터 읽는다.

- `p[3]`: `p`는 크기 3인 배열이다
- `*p[3]`: `p`는 포인터의 배열이다
- `int *p[3]`: `p`는 `int`의 포인터의 배열이다

`p`는 크기 3인 배열이고 `p[0]`, `p[1]`, `p[2]`는 모두 `int`의 포인터이다.

정리하면 다음과 같다.
```C++
int *p[3];
p[0] = new int[2]
p[1] = new int[5];
p[2] = new int[4];

p[0][1] = 55;
p[2][3] = 999;
// 코드
delete[] p[0];
delete[] p[1];
delete[] p[2];
```

### 배열 포인터

배열 포인터는 배열의 포인터를 말한다. 배열 포인터는
```C++
int (*p)[3];
```
와 같은 꼴로 선언한다. 이것을 읽어 보자.

- `*p`: `p`는 포인터이다
- `(*p)[3]`: `p`는 크기 3인 배열의 포인터이다
- `int (*p)[3]`: `p`는 `int`의 배열의 포인터이다

`p`는 `int`의 배열을 가리키는 포인터이다. 동적으로 메모리를 할당하려면
```C++
p = new int[2][3];
p[1][2] = 123;
```
으로 작성한다. `p[0]`와 `p[1]`은 `int[3]` 형식이다.

정리하면 다음과 같다.

```C++
int (*p)[3] = new int[2][3];
p[0][1] = 55;
p[1][2] = 999;
// 코드
delete[] p;
```

**연습문제 1.** *선언*
```C++
int *(*p)[3];
```
*을 읽으시오. 동적으로 메모리를 할당하여 사용하시오.*

### 참고
한 요소의 포인터
```C++
int *p = new int;
delete p;
```
와
```C++
int *p = new int[1];
delete p[];
```
는 다를 것이 없다. `delete`와 `delete[]`는 선언하는 모양에 따라 선택한다.

배열 포인터
```C++
int (*p)[3] = new int[1][3];
```
은 한 개짜리 포인터지만
```C++
int (*p)[3] = new int[3];
```
으로 바꿔 쓸 수 없다.

### 참고
Visual Studio Community 2017에서 메모리 누수(memory leak)를 탐지하려면 `main()`의 맨 앞에
```C++
_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);
```
를 적는다. 
```C++
#define _CRTDBG_MAP_ALLOC
#include <stdlib.h>
#include <crtdbg.h>

int main()
{
    _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);

    int *p = new int;

    system("pause");
    return 0;
}
```
디버깅하면 메시지
```
Detected memory leaks!
```
을 볼 수 있다.
