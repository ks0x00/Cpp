# 헤더 파일 동작 방식
헤더 파일은 소스 코드 컴파일에 필요한 정보를 포함한다. 자세한 것은 따로 찾아보기 바란다. 여기서는 헤더 파일의 동작 방식과 사용할 때 주의할 점을 알아본다.

아래 나열된 코드는 Visual Studio 2017 Community에서 프로젝트를 생성할 때, "빈 프로젝트"로 설정하여 생성한 프로젝트의 코드이다.

      파일 -> 새로 만들기 -> 프로젝트 -> Visual C++ -> 빈 프로젝트

## #include
#include로 헤더 파일을 불러오면 그 자리에 해당 파일이 삽입된다. 예를 들어,
```C++
#pragma once
// 코드 1
#include "a.h"
// 코드 2
```
를 컴파일하면 <i>파일 a.h가 ```//코드 1```과 ```//코드 2``` 사이에 삽입</i> 된다.

## #pragma once

헤더 파일 맨 앞에 오는 `#pragma once`의 역할에 대하여 모르는 사람은 많지 않을 것이다. 그런데 그것을 제거하면 왜 오류가 발생할까?
여러 가지 경우가 있다. 여기서는 #include의 동작과 관련된 간단한 예를 살펴본다.

헤더 파일 foo.h에서 bar.h를 불러오고, bar.h에서 다시 foo.h를 불러온다고 하자. 코드는 다음과 같을 것이다.

**파일 foo.h**
```C++
#include "bar.h"
// 코드
```

**파일 bar.h**
```C++
#include "foo.h"
// 코드
```
헤더 파일 foo.h를 불러오기 위하여, 파일 main.cpp를

**파일 main.cpp**
```C++
#include "foo.h"
// 코드
```
로 작성한다고 하자. 이 코드를 컴파일하면 어떤 일이 벌어질까. 우선 `#include "foo.h"` 자리에 파일 foo.h의 내용이 복사되어 삽입된다.
삽입해 놓고 보면
```C++
/////////////////////////
// foo.h
#include "bar.h"
// 코드
////////////////////////
// 코드
```
가 된다.

그런데 `#include "bar.h"` 가 있으므로 그 자리에 다시 파일 bar.h의 내용이 복사되어 삽입된다.
삽입해 놓고 살펴보면 이 과정이 끝나지 않는다는 것을 짐작할 수 있다.

C/C++ 컴파일러가 제시하는 해결 방법은 헤더 파일을 한 번만 불러오도록 제한하는 것이다. `#pragma once`는 해당 파일을 한 번만 불러오도록
제한하는 역할을 한다. foo.h와 bar.h의 맨 앞에 `#pragma once`가 추가하여 불러오는 과정을 한 번만 수행한다.
내용은 한 번만 불러오는 것으로 충분히 알 수 있다.

## 주의할 점
### 헤더 파일에서 다른 헤더 파일을 불러오는 것을 피하자

프로그램이 단순하면 한 헤더 파일에서 다른 헤더 파일을 불러오는 것이 편리하다. 그러나 조금만 커져도 그것들은 문제를 일으킨다.
프로그램 전체에서 사용하는 상수, 함수 등을 포함하는 헤더 파일은 불러오는 것이 편리하지만 그 외에는 피하는 것이 좋다.
초보 시절 흔히 저지르는 실수 중 하나이다.

### 헤더 파일에 의존하는 헤더 파일을 만들지 말자

헤더 파일은 독립적으로 동작하는 것이 좋다. 한 헤더 파일을 사용하기 위하여 다른 헤더 파일을 불러와야 한다면
"헤더 파일에서 다른 헤더 파일을 불러오는 것"과 비슷한 문제를 일으킨다. 역시 초보 시절 흔히 저지르는 실수 중 하나이다.

다음 세 파일을 보자.

**파일 foo.h**
```C++
#pragma once

#include <iostream>
void f()
{
    std::cout << 1;
}
```

**파일 bar.h**
```C++
#pragma once

void g()
{
    f();
}
```

**파일 main.cpp**
```C++
#include "foo.h"
#include "bar.h"
#include <iostream>

int main()
{
    g();

    system("pause");
    return 0;
}
```
이 코드는 잘 동작하며 원하는 결과를 출력한다. 그러나 bar.h를 불러오기 전에 반드시 foo.h를 불러와야 한다.
컴파일할 때 함수 `f()`에 관한 정보, 정확히 말하면 `f()`의 시그니처(signature)가 필요한데, foo.h를 먼저 불러와야
그것을 알 수 있기 때문이다.

main.cpp에 `#include "foo.h"`가 없거나 `#include "bar.h"`보다 뒤에 오면 오류가 발생한다.
코딩하면서 이것을 고려하는 것은 귀찮은 일이다. 게다가
나중에 그 파일을 사용할 때는 그와 같은 연관성을 까맣게 잊고 오류에 당황하는 경우도 있다.

각각의 경우 해결 방법이 다르지만, 위 문제의 경우에는 bar.h와 bar.cpp를 나누어 작성하면 된다.
bar.h에는 힘수의 시그시처를, bar.cpp에는 본문을 적는다.

**파일 bar.h**
```C++
#pragma once

void g();
```

**파일 bar.cpp**
```C++
#include "foo.h"
#include "bar.h"

void g()
{
    f();
}
```
이와 같이 분리하면 컴파일할 때 불러올 헤더 파일의 순서를 고려하지 않아도 된다.
또, main.cpp에 ```#include "foo.h"```를 적지 않아도 된다.
